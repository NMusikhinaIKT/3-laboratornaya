.686
.model flat,stdcall
.stack 100h
.data

arr_k dd 8.0 ; 0 элемент 4 байта два слова - короткий формат
	  dd -0.125 ; 1 элемент 4 байта два слова - короткий формат
	  dd 4.0 ; 2 элемент 4 байта два слова - короткий формат
	  dd -0.25 ; 3 элемент 4 байта два слова - короткий формат
	  dd 7.0 ; 4 элемент 4 байта два слова - короткий формат
znach1 dd 0.0 ; 0 элемент для сохранения результата 1 расчета
       dd 0.0 ; 1 элемент для сохранения результата 2 расчета
       dd 0.0 ; 2 элемент для сохранения результата 3 расчета
       dd 0.0 ; 3 элемент для сохранения результата 4 расчета
       dd 0.0 ; 4 элемент для сохранения результата 5 расчета
       dd 0.0 ; 5 элемент для сохранения результата 6 расчета
       dd 0.0 ; 6 элемент для сохранения результата 7 расчета
       dd 0.0 ; 7 элемент для сохранения результата 8 расчета
       dd 0.0 ; 8 элемент для сохранения результата 9 расчета
       dd 0.0 ; 9 элемент для сохранения результата 10 расчета

CHISLO dd -1.0 ; переменная для сравнения 
NULL dd 0.0 ; переменная для обнуления счетчика перпендикулярных прямых

.code
ExitProcess PROTO STDCALL :DWORD
Start:

	FINIT;инициализация сопроцессора

	;расчет ПЕРВОГО элемента со всеми остальными

	FLD arr_k[0*4] ; помещаем в ST0 0 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[1*4] ; умножаем значение в ST0 на 1 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[0*4] ; помещаем результат в 0 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[0*4] ; помещаем в ST0 0 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[2*4] ; умножаем значение в ST0 на 2 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[1*4] ; помещаем результат в 1 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[0*4] ; помещаем в ST0 0 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[3*4] ; умножаем значение в ST0 на 3 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[2*4] ; помещаем результат в 2 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[0*4] ; помещаем в ST0 0 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[4*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[3*4] ;помещаем результат в 3 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	;расчет ВТОРОГО элемента со всеми остальными

	FLD arr_k[1*4] ; помещаем в ST0 1 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[2*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[4*4] ; помещаем результат в 4 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[1*4] ; помещаем в ST0 1 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[3*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[5*4] ; помещаем результат в 5 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[1*4] ; помещаем в ST0 1 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[4*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[6*4] ; помещаем результат в 6 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	;расчет ТРЕТЬЕГО элемента со всеми остальными

	FLD arr_k[2*4] ; помещаем в ST0 2 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[3*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[7*4] ; помещаем результат в 7 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	FLD arr_k[2*4] ; помещаем в ST0 2 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[4*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[8*4] ; помещаем результат в 8 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

	;расчет ЧЕТВЕРТОГО элемента со всеми остальными

	FLD arr_k[3*4] ; помещаем в ST0 3 элемент массива *4 означает, что элемент соотвествует двойному слову
	FMUL arr_k[4*4] ; умножаем значение в ST0 на 4 элемент массива *4 означает, что элемент соотвествует двойному слову
	FST znach1[9*4] ; помещаем результат в 9 элемент массива znach1
	FFREE ST(0) ; очистка регистра стека

mov ecx, 10d ; устанавливаем количество итераций
mov ebx, 0d ; здесь регистр ebx отвечает за номера элементов массива
@cycle: ; начало цикла
    FLD CHISLO 
	FLD znach1[ebx*4]
	FCOMI ST, ST(1) ; сравниваем два числа
	je L1; если значение равные, то переходим к метке L1
	jae L2; проверяем условие ST(0) >= ST(i) и идем к метке L2
	jbe L2; проверяем условие L2 ST(0) <= ST(i) и идем к метке L2
	L1:
	FCHS ; меняем знак на противоположный
	FST znach1[ebx*4] ; записываем значение в элементы массива
	jmp L3 ; переход к метке 
	L2:
	FLD NULL
	FST znach1[ebx*4]
	jmp L3
	L3:
	FFREE ST(0); очистка регистра стека
	FFREE ST(1); очистка регистра стека
	FFREE ST(2); очистка регистра стека
	FFREE ST(3); очистка регистра стека
	FFREE ST(4); очистка регистра стека
	FFREE ST(5); очистка регистра стека
	FFREE ST(6); очистка регистра стека
	FFREE ST(7); очистка регистра стека
	add ebx, 1d
loop @cycle ; конец цикла

FLD znach1[0*4]
FADD znach1[1*4]
FADD znach1[2*4]
FADD znach1[3*4]
FADD znach1[4*4]
FADD znach1[5*4]
FADD znach1[6*4]
FADD znach1[7*4]
FADD znach1[8*4]
FADD znach1[9*4]; количество перпендикулярных прямых в ST(0)
exit:
Invoke ExitProcess,1
End Start
